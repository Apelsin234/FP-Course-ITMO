# L is for literature to read
# HWTi is for `theory` homeworks (checked offline, no need practice for it)
# HWPi is for `practice` homeworks

Week 1. Haskell Smooth Intro
  Lecture 1: Why FP and haskell
    * Reallife examples
      * facebook haxl
      * google
      * microsoft bond
      * Nixos
      * Xmonad
      * pandoc
      * parsec
      * hbro
      * acm icfp
    * Nice examples from here: https://wiki.haskell.org/Haskell_a_la_carte
  Lecture 2: Basic syntax
    * simple examples
      * type notation (fixed like Int or Double)
      * binary operations
      * calc-like structures
      * algorithms on lists 
      * Data.List standard library, `import` without details and some examples in ghci online
    * give instruction of how to install haskell with cabal on Linux; how to install it on Windows (MAC users will figure it out themselves)
    * few words about modules and haskell infrastructure
    * suggest tutorials and other online useful courses
      * LearnYourHaskell: http://learnyouahaskell.com/chapters
      * anton-k-github: http://anton-k.github.io/ru-haskell-book/book/home.html
      * Haskell in Real Life: http://book.realworldhaskell.org/read/
      
  L: read https://wiki.haskell.org/Haskell_in_practice
  L: read LearnYourHaskell (chapter 2) http://learnyouahaskell.com/starting-out  
      
Week 2. Haskell Datas(1) and advanced syntax
  # лекция про data & classes & instances разбита на две части, чтобы к каждому пункту добавить примеры;
  # возможно, логичней было бы рассказать всё вместе и сразу, но хочется дать такие основы, чтобы уже задать первое дз;
  # pattern matching относится к секции _More syntax_, но идёт после рассказа про data, чтобы было осмысленней;
  # также по возможности будет производиться сравнение с другими языками программирования
  Lecture 3: Datas, Classes, Instances. Part 1
    * `type` keyword: type alias, String aka [Char]
    * ADT's (algebraic data types): 
      * sum of types (aka enums)
      * product of types (aka `struct`'s in C++ or `class`'es in Java)j
      * What we want in perfect world: different Enum instances with different fields (cannot do this in java)
    * `data` keyword
      ex1: days of week, planetes (simple sum of types)
      ex2: Point of two doubles (simple product of types) :: data DoublePoint = DoublePoint Double Double
      ex3: Some parameterized type :: data Point a = Point a a (compare to C++ templates and Java Generics)
      * name of constructors
      ex4: parametrized sum of products :: data Geom = Point2D a a | Vector3D a a a
      ex5: recursive data types (List, Tree)
      ex6: Person -- {record syntax} (compare to fields or properties in Java, C#, Kotlin)
    * `class` keyword 
      * compare to Java interface
      * examples of standard classes {Eq, Ord, Bounded, Fractional, Show, Read}
    * `instance` keyword (implementations of `class`'es)
      * compare with inheritance in other languages
      * compare with extension functions in Kotlin
      ex: implement Eq, Ord, Bounded for Week and Point
    * deriving; automatic implementations (deriving) for Eq, Ord, Bounded, Show, Read
    * type constraints on functions (aka type bounds and polymorphism)
      * calc-like data structures from lecture 2 with correct type and constraints  
      
  # в лекции 4 планируется каждую синтаксическую конструкцию сопровождать примерами из других языков для сравнения и понимания;
  # структура слайда на каждую конструкцию следующая: 
  #   1) заголовок - имя конструкции
  #   2-) пример кода ближайшего аналога в популярном императивном языке (Java, C++)
  #   3+) пример кода более точного аналога в других языках (Python, JavaScript, иногда более экзотические: Kotlin, Rust, etc.)
  #   4!) наконец, сниппет кода, выполняющего то же самое, на Haskell
  #   5*) ноль или более дополнительных слайдов других примеров, если вдруг не будет влезать на один ввиду большого числа аналогов 
  Lecture 4: More syntax
    * difference between statement and expression
    * lambda (anonymous functions)
      - Java 7 (anonymous classes), C++ < C++11 -- :(
      + Java 8 (@FunctionalInterface), C++11 ([](){})
      ! \x y -> x + y
      * Python :: `lambda` x: x * 2
        JS :: var f = function(){...}; 
        Kotlin :: { x :: Int, y :: Int -> x + y}  
        Rust :: let plus_one = |x: i32| x + 1;
    * `if` expression
      - Java
      + Python (ternary operator), Kotlin (`if` is expression)
      ! if p then a else b
    * `let` (variable declaration)
      - Java (int x = 10; -- statement)
      + Rust (`let` x = 10; - same word!, `if let = someVar { ... }` construction - binding to use 'someVar' in `if`'s body)
      ! `let` h = head l `in` h + 10
    * `guards`
      - simple `if`
      ! f :: Bool -> Int
        f p
        | p = 1
        | otherwize = 2
    * `case` expression
      - Java (switch :: ints, enums, strings)
      + Kotlin (`when` expression), Rust (`match` expression)
      ! case x of
          0 -> "0"
          _ -> "not zero"
    * `where` clause
      - Java (inner classes, anonymous classes); lambdas; local variables
      + Python, JS :: inner functions
      ! f x = z 
        `where` z = y
      * Kotlin :: nested functions, return from outer function
        Rust :: local functions 
    * recursion & pattern matching
      - Java :: `if`, function overloading
      + C++ :: template by value overloading
      !1 fact 0 = 1
         fact n = n * fact (n - 1)
      !2 alternative to record syntax and some example with data's
      !3 named arguments in haskell aka l@(x:xs)
      * Kotlin, Python :: default and named arguments in functions (some similarity with pattern matching)
        Kotlin, Rust :: real pattern matching
    * Higher order functions, HOF (map, filters, etc.)
      - Java 8 :: lambdas, C++ :: pointer on function
      + C++11 :: auto, std::function
      ! map (*2), filter (<3)
      * JS, Python :: dynamic types
        Kotlin :: static types
    * ($) ; (.) function compositions
      - Java 8 :: map(...).filter(...).....toArray()
      + Kotlin :: HOF and syntax sugar (strings filter {it.length == 5} sortBy {it} map {it.toUpperCase()})
      ! filter (<3) . map (*2) $ ls  
    * list ranges
      - Java 8 :: IntStream.range
      + Python :: range(from, to, step), Kotlin or Swift `from..to` ranges and `from..<to`
      ! [1..], [1,3..10], [0..n]
    * list comprehension
      - C++, Java
      + Python :: [i for i in range(10)], Kotlin Array<T>(size: Int, init: Int -> T) 
      ! [ (x, y) | x <- [1..10], y <- [1..10] ]
 
  L: LearnYourHaskell (chapter 3-6,8) http://learnyouahaskell.com 
  HWP1: 1) sum of integers from strings; 2) reverse list, fast Fibonacci computation; 3) some task from CodeForces or HackerRank
  HWP2: implement naive binary tree and AVL-binary tree, write some tests, compare execution time of inserting range [1..5000]
    
Week 3. Haskell Datas(2) and HW's
  Lecture 5: Datas, Classes, Instances. Part 2
    * type constraints on datatypes: data (Show a) => Exp a = Const a | Eq (Exp a) (Exp a)
    * introducing maybe without saying `monad` word as some kind of nullable class
      * data Maybe a = Nothing | Just a
      * compare to C++ (boost::optional), Java (Optional<T>), Kotlin (Delegates.notNull()) 
    * parametrized classes and instances:
      * examples of Eq, Show on Maybe a
    * newtype: newtype Sum a = Sum a
    * useful Monoid class
      * examples and applications
      * foldrs on monoids
    * FlexibleInstances (Monoid on "newtype Sum a" and "newtype Product a")
    * type families
    * more on recursive datatypes and haskell lazyness
      * repeat (infinite list)  
  Practice 1: Accepting (or failing) HW1P & HW2P
  
  L: LearnYourHaskell (chapters 3,8,11:newtype:monoids) http://learnyouahaskell.com/
  HWP3 : implement more complex data structure and some algorithm on it
  
Week 4. Control Work 1 and Practice
  CW1: Haskell Basics
    1) Some simple program in a few lines
    2) implement some simple Data Structure (Stack with Min in current stack, Queue on Two stacks, Deque or smth else)
    3) implement some DS and some class instances for it

  Practice 2: Accepting HW's after CW is done
  
  L: prepare yourselves to hardcore -- read about functors and applicative
  LearnYourHaskell (chapter 11) http://learnyouahaskell.com/functors-applicative-functors-and-monoids
   
Week 5. Intro to Functors   
  Lecture 6-6.5: Functors, Applicative Functors
    * fmap
    * applicative
      * what for
      * pure
      * <*>
    * liftA
    * do syntax with explanation
      * `<-` assignment
    * introduce monad Maybe, Either with no _monad_ word;
    * implement functor and applicative instances for Maybe, Either
    * mention about GHC 7.10 (assign myself)
    * examples: 
      * `ZipList`, https://en.wikibooks.org/wiki/Haskell/Applicative_Functors 
      * `User`, https://pbrisbin.com/posts/applicative_functors/  
      * `Applicative parser`, https://robots.thoughtbot.com/applicative-options-parsing-in-haskell
      * Small things: http://stackoverflow.com/questions/6570779/why-should-i-use-applicative-functors-in-functional-programming
      * Accumulation of expression: http://anton-k.github.io/ru-haskell-book/book/7.html
      * Applicative command line arguments parser: https://github.com/pcapriotti/optparse-applicative
    
    Practice 3: Accepting HW's in remaining time
      
  L: LearnYourHaskell (chapter 11) http://learnyouahaskell.com/functors-applicative-functors-and-monoids 
     
  HWT1: implement <$>
  HWT2: prove Functor laws
  HWT3: prove Applicative Laws 
  
  HWP4 : some task on applicative
    
Week 6. Monads, Finally    
  Lecture 7: Monads 1
    * maybe as example (boost::optional) (yes, again)
    * philosophy about null-safety, exception handling
    * monad class
      * bind 
      * return
      * then
      * error
    * Maybe instance
    * List monad instance
    * Reader, Writer (logging with examples)
      
  Practice 4: accepting homeworks
  
  L: LearnYourHaskell (chapters 12, 13) http://learnyouahaskell.com/a-fistful-of-monads 
  
  HWP4: implement all examples from slides with Either monad instance (and instance itself too) 
  Announce HWT4 and HWP5 (so people can start earlier)
   
Week 7. More Monads
  Lecture 8: Monads 2
    * liftM
    * `State` monad
      * why newtype and more about record syntax
      ex0: variable assignment (trivial, but useful for understand)
      ex1: random numbers
      ex2: stack
      ex3: Dijkstra
      * where to find `State` monad in std library
    * MonadFish and MonadJoin
    
  Practice 5: accepting homeworks  
     
  L: LearnYourHaskell (chapters 12, 13) http://learnyouahaskell.com/a-fistful-of-monads
  
  HWT4: prove monad laws
  HWT5: prove equivalence of Monad, MonadJoin, MonadFunctor (Categories from ITMOPrelude)
  
  HWP5: write a game. For example: 2 players, 10 steps, each step = random
  points to a person, The winner is the one who has more. Here can be a labyrinth
  random walking game, or Cows and Bulls game (classic)
  HWP6: implement some algorithms or data structures with ST monad (DFA for example)
    
Week 8. IO
  Lecture 9-9.5: IO
    ### intro ###
    * intro to IO and impure functions
    * do syntax and some imperative style
    * how to read from user input (lot of functions)
    * mapM_ and company
    * how to read from files (lot of functions)
    * streams
    * command line arguments
    ### efficient IO ###
    * bytes and bytestrings
    * IOExceptions like in Java?
    
  Practice 6: Accepting HWP4 & HWP5 (in remaining time)
    
  L: anton-k IO http://anton-k.github.io/ru-haskell-book/book/8.html
  L: LearnYourHaskell (chapter 9) http://learnyouahaskell.com/input-and-output
  L: Real World Haskell (chapters 7-9) http://book.realworldhaskell.org/read/
  
  HWP7: implement some grep-like program, searching in files or user input, reading commandline arguments
  hw-hint: it is good to use applicative args parser: https://github.com/pcapriotti/optparse-applicative
  
Week 9. Monadic parsers
  Lecture 10: Monadic Parser
    * Explaining Monadic Parser's idiom on examples
      * brackets parser
      * numbers parser
      * arithmetic expression parser
    * Parsec, Happy
    
  Practice 7: Accepting last hw's
    
  HWP8: write some monadic parsers from scratch

Week 10. Advanced haskell
  Lecture 11: 
    * arrows
    * vector
    * introducing StateT
    * difference from simple monads
    * examples and applications
    
  Practice 8: Accepting homeworks
  
  HWP9: some mutable algorithm with transformers (convert list to set, dfs, smth else) 
  HWP10: Monadic parser with transformer monad (in education purpose)
    
Week 11. Control Work 2 and Practice 
  CW2: Monads
    1) Write Functor instance
    2) Write Monad instances
    3) write smth small using simple monads (Maybe, Either, State)
    4) write smth with StateTransformers
    
  Practice 9: in remaining time
  
Week 12. Deforestation and Stream Fusion (some relax after monads)
  Lecture 12: Speeding up haskell
    * remember haskell lazyness
    * CPS
    * foldr vs. foldl
      * stack problems
      * `seq`, `deepseq`, `pseq`
    * foldl' + weak head normal form etc.
    * problems with list ++
      * DiffList
    * https://www.haskell.org/haskellwiki/ListT_done_right
    * Deforestation
      * explaining in simple words
      * formal algorithm
      * example of deforesting smth simple
    * Stream fusion
    
  Practice 10: Accepting HWP9-10
    
  L: articles about deforestation and SF  
  
  HWT6: fuse and deforest some functions in theory
  HWP11: measure time of fused and naive functions, implementing Discrete cosine transformation (DCT) for example, some Segal-like algo

Week 13. Zippers and Lens (Most powerful haskell weapon)
  Lecture 13: From Zippers to Lens
    * couple words about zippers and ZipperFS
      * ZipList
      * Deriviatives
    * Lens (lens vs zippers)
    * More Lens explanation and examples (one more intro to imperative style in haskell)
    
  Practice 11: Accepting HWP10 (in remaining time)
  
  L: LearnYourHaskell (chapter 14) http://learnyouahaskell.com/zippers 
   
  HWP12: implement some algos on graphs using Lens
  HWP13: Records with lens, create library for filetree walking, filtering, modifying (see System.Directory.Tree)  
  
Week 14. Haskell Concurrency
  Lecture 14: Multicore programming in Haskell 
    * !!! http://chimera.labs.oreilly.com/books/1230000000929
    * profits of immutability
    * already have immutability. Is it enough?
    * the answer is no because
      * we have critical sections
      * we want to wait threads execution
      * we want background tasks, daemons, sleeps, interruptions, or we don't? 
      * how to achive infinite execution with lazyness?
    * simple multithreaded: 
      * ex1: fibonacci computation
      * ex2: primes sieve
    * `par` implicit parallelism
      * comparison with Java 8 `parallelMap`
    * locks, waits, critical section
      * forks
      * thread intercommunication
    * couple words about ErlangVM (or BEAM: Björn's Erlang Abstract Machine)
    
  Practice 12: Accepting HWP12-13
  
  L: haskell threads doc
  L: RealWorldHaskell (Chapter 24. Concurrent and multicore programming)
     http://book.realworldhaskell.org/read/concurrent-and-multicore-programming.html
  L: https://donsbot.wordpress.com/2009/09/05/defun-2009-multicore-programming-in-haskell-now/
  
  HWP14: write some multithreaded program (producer-consumer queue or smth. more interesting)
 
Week 15. Haskell Gui
  Lecture 15: Gui in Haskell
    * gtk
    * wxwidgets
    * opengl!
    * api
    * simple examples
      * haskell-CG
      * xmonad as WM
  
  Practice 13: Accepting HWP14
      
  L: docs
  
  HWP15: write some program with GUI 
    
Week Last: Control work 3 and Practices
  CW3: Haskell In Real World
    1) deforest or fuse smth
    2) some imperative program with lens
    3) some concurrency program
 
  Practice 13: Accepting everything  

### Возможные лекции в оставшееся время (если оно будет) ###
Week ??. Haskell Advanced (in remaining lectures)      
  Lectures ??-inf: what can be explained from topics lower
    * couple words about forall a. a -> a -> a (intro and why we need this)
      * синтаксический сахар для избавления от forall 
      * http://stackoverflow.com/questions/3071136/what-does-the-forall-keyword-in-haskell-ghc-do
      * forall, RankNTypes (http://sleepomeno.github.io/blog/2014/02/12/Explaining-Haskell-RankNTypes-for-all/)
    * GADT's: 
      {-# LANGUAGE GADTs #-}
      data Exp a where
          Const :: Show a => a -> Exp a
          Eq :: Exp a -> Exp a -> Exp a
    * Profiling
    * Testing
    * databases
    * networks
    * WEB, HTTP, JSON (Hakyll, Yesod, Snap)
    * FFI 
    * ghc internals
    * ?????
    * PROFIT!!!!
